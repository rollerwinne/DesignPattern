## 设计模式七大原则


1. 单一职责原则（Single Responsibility Principle）
    + 降低类的复杂度,一个类只负责一项职责。
    + 提高类的可读性,可维护性。
    + 降低变更引起的风险
    + 通常情况下, **我们应当遵守单一职责原则** ,只有逻辑足够简单,才可以在代码级违反单一职责原则；只有类中方法数量足够少,可以在方法级别保持单一职责原则

2. 接口隔离原则 （Interface Segregation Principle）
    + 一个类对另一个类的依赖应该建立在最小的接口上
    
3. 依赖倒转原则 (Dependence Inversion Principle)
    + 高层模块不应该依赖低层模块,二者都应该依赖其抽象
    + 抽象不应该依赖细节,细节应该依赖抽象
    + 依赖倒转(倒置)的中心思想是面向接口编程
    + 依赖倒转原则是基于这样的设计理念：相对于细节的多变性,抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中,抽象指的是接口或抽象类,细节就是具体的实现类
    + 使用接口或抽象类的目的是制定好**规范**,而不涉及任何具体的操作,把展现细节的任务交给他们的实现类去完成
    + 三种方式传递依赖：
        + 接口传递
        + 构造方法传递
        + setter传递
    + 注意事项
        + 低层模块尽量都要有抽象类或接口,或者两者都有,程序稳定性更好
        + 变量的声明类型尽量是抽象类或接口,这样我们的变量引用和实际对象间,就存在一个缓冲层,利于程序扩展和优化
        + 继承时遵循里氏替换原则

4. 里氏代换原则 (Liskov Substitution Principle)
    + 里氏替换原则是在1988年,由麻省理工学院的以为姓里的女士提出的
    + 如果对每个类型为T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有的对象o1都代换成o2时,程序P的行为没有发生变化,那么类型T2是类型T1的子类型。换句话说,**所有引用基类的地方必须能透明地使用其子类的对象**
    + 在使用继承时,遵循里氏替换原则,在子类中**尽量**不要重写父类的方法
    + 里氏替换原则告诉我们,继承实际上让两个类耦合性增强了,**在适当的情况下,可以通过聚合,组合,依赖来解决问题。**
    + 在实际编程中,我们常常会通过重写父类的方法完成新的功能,这样写起来虽然简单,但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候。
    + 通用的做法是：原来的父类和子类都继承一个更通俗的基类,原有的继承关系去掉,采用**依赖**,**聚合**,**组合**等关系代替

5. 开闭原则 (Open Closed Principle)
    + 开闭原则是编程中最基础、最重要的设计原则
    + 一个软件实体如类,模块和函数应该对扩展开放(对提供方),对修改关闭(对使用方)。用抽象构建框架,用实现扩展细节。
    + 当软件需要变化时,尽量通过**扩展**软件实体的行为来实现变化,而不是通过**修改**已有的代码来实现变化。
    + 编程中遵循其它原则,以及使用设计模式的目的就是遵循**开闭原则**

6. 迪米特法则 (Demeter Principle)
    + 一个对象应该对其他对象保持最少的了解
    + 类与类关系越密切,耦合度越大
    + 迪米特法则又叫**最少知道原则** ,即一个类对自己依赖的类知道的越少越好。也就是说,对于被依赖的类不管多么复杂,都尽量将逻辑封装在类的内部。对外除了提供的public方法,不对外泄露任何信息
    + 迪米特法则还有个更简单的定义：只与**直接的朋友**通信
    + 直接的朋友：每个对象都会与其他对象有**耦合关系**,只要两个对象之间有耦合关系,我们就说这两个对象之间是朋友关系。耦合的方式很多,依赖,关联,组合,聚合等。其中,我们称出现**成员变量**,**方法参数**,**方法返回值**中的类为直接的朋友,而出现在局部变量中的类不是直接的朋友。也就是说,陌生的类最好不要以局部变量的形式出现在类的内部。
    + 迪米特法则的核心是降低类之间的耦合
    + 但是注意：由于每个类都减少了不必要的依赖,因此迪米特法则只是要求降低类间对象间耦合关系,并不是要求完全没有依赖关系

7. 合成/聚合复用原则 (Composite Reuse Principle)
    + 尽量使用合成/聚合,而不是通过继承达到复用的目的
    
## 七大原则的核心思想

1. 找出应用中可能需要变化之处,把它们独立出来,不要和那些不需要变化的代码混在一起。

2. 针对接口编程,而不是针对实现编程。

3. 为了交互对象之间的松耦合设计而努力


